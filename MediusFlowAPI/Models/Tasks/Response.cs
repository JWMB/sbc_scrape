// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var response = Response.FromJson(jsonString);

namespace MediusFlowAPI.Models.Tasks
{
	using System;
	using System.Collections.Generic;

	using System.Globalization;
	using Newtonsoft.Json;
	using Newtonsoft.Json.Converters;

	public partial class Response
	{
		[JsonProperty("$type")]
		public string Type { get; set; }

		[JsonProperty("FullName")]
		public string FullName { get; set; }

		[JsonProperty("DisplayName")]
		public string DisplayName { get; set; }

		[JsonProperty("IsLabelColumnVisible")]
		public bool IsLabelColumnVisible { get; set; }

		[JsonProperty("Tasks")]
		public Task[] Tasks { get; set; }

		[JsonProperty("Columns")]
		public Column[] Columns { get; set; }

		[JsonProperty("TotalTasks")]
		public long TotalTasks { get; set; }
	}

	public partial class Column
	{
		[JsonProperty("$type")]
		public string Type { get; set; }

		[JsonProperty("Name")]
		public string Name { get; set; }

		[JsonProperty("SourceKey")]
		public string SourceKey { get; set; }

		[JsonProperty("Sortable")]
		public bool Sortable { get; set; }

		[JsonProperty("OrderByKey")]
		public string OrderByKey { get; set; }
	}

	public partial class Task
	{
		[JsonProperty("$type")]
		public string Type { get; set; }

		[JsonProperty("Document")]
		public Document Document { get; set; }

		[JsonProperty("IsUnread")]
		public bool IsUnread { get; set; }

		[JsonProperty("InReview")]
		public bool InReview { get; set; }

		[JsonProperty("TaskId")]
		public long TaskId { get; set; }

		[JsonProperty("DocumentId")]
		public long DocumentId { get; set; }

		[JsonProperty("DocumentIdentifier")]
		public string DocumentIdentifier { get; set; }

		[JsonProperty("TaskDescription")]
		public string TaskDescription { get; set; }

		[JsonProperty("Activity")]
		public string Activity { get; set; }

		[JsonProperty("LabelsIds")]
		public object[] LabelsIds { get; set; }
	}

	public partial class Document
	{
		[JsonProperty("$type")]
		public string Type { get; set; }

		[JsonProperty("InvoiceNumber")]
		[JsonConverter(typeof(ParseStringConverter))]
		public long InvoiceNumber { get; set; }

		[JsonProperty("Amount")]
		public Amount Amount { get; set; }

		[JsonProperty("Amount_Currency_Code")]
		public string AmountCurrencyCode { get; set; }

		[JsonProperty("Supplier_Name")]
		public string SupplierName { get; set; }

		[JsonProperty("Company_Name")]
		public string CompanyName { get; set; }

		[JsonProperty("Id")]
		public long Id { get; set; }

		[JsonProperty("DueDate")]
		public string DueDate { get; set; }

		[JsonProperty("CustomFields_TextCustomField1")]
		[JsonConverter(typeof(ParseStringConverter))]
		public long CustomFieldsTextCustomField1 { get; set; }
	}

	public partial class Amount
	{
		[JsonProperty("$type")]
		public string Type { get; set; }

		[JsonProperty("CurrencyCode")]
		public string CurrencyCode { get; set; }

		[JsonProperty("DisplayValue")]
		public string DisplayValue { get; set; }
	}

	public partial class Response
	{
		public static Response[] FromJson(string json) => JsonConvert.DeserializeObject<Response[]>(json, Converter.Settings);
	}

	public static class Serialize
	{
		public static string ToJson(this Response[] self) => JsonConvert.SerializeObject(self, Converter.Settings);
	}

	internal static class Converter
	{
		public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
		{
			MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
			DateParseHandling = DateParseHandling.None,
			Converters =
			{
				new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
			},
		};
	}

	internal class ParseStringConverter : JsonConverter
	{
		public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

		public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null) return null;
			var value = serializer.Deserialize<string>(reader);
			long l;
			if (Int64.TryParse(value, out l))
			{
				return l;
			}
			throw new Exception("Cannot unmarshal type long");
		}

		public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
		{
			if (untypedValue == null)
			{
				serializer.Serialize(writer, null);
				return;
			}
			var value = (long)untypedValue;
			serializer.Serialize(writer, value.ToString());
			return;
		}

		public static readonly ParseStringConverter Singleton = new ParseStringConverter();
	}
}
